"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsString = void 0;
const class_validator_1 = require("class-validator");
const core_1 = require("../core");
const custom_validator_1 = require("./utils/custom-validator");
const dateValidators = {
    date: {
        validator: (value) => /^\d{4}-\d{2}-\d{2}$/.test(value) && !isNaN(new Date(value).getDate()),
        message: ({ property }) => `${property} is not formatted as \`yyyy-mm-dd\` or not a valid Date`,
    },
    'date-time': {
        validator: (value) => (0, class_validator_1.isISO8601)(value, { strict: true }) && !isNaN(new Date(value).getDate()),
        message: ({ property }) => `${property} is not in a ISO8601 format.`,
    },
};
const IsString = ({ maxLength, minLength, pattern, canBeEmpty, isEmail, isDate, customValidate, ...base } = {}) => (0, core_1.compose)({
    type: 'string',
    minLength,
    maxLength,
    ...(isEmail && { format: 'email' }),
    ...(isDate && { format: isDate.format }),
    pattern: pattern?.regex?.toString()?.slice(1, -1), // removes trailing slashes
}, base, (0, class_validator_1.IsString)({ each: !!base.isArray }), canBeEmpty || minLength !== undefined || maxLength !== undefined
    ? (0, class_validator_1.Length)(minLength ?? 0, maxLength, { each: !!base.isArray })
    : core_1.noop, isEmail ? (0, class_validator_1.IsEmail)(undefined, { each: !!base.isArray }) : core_1.noop, pattern ? (0, class_validator_1.Matches)(pattern.regex, { message: pattern.message, each: !!base.isArray }) : core_1.noop, isDate ? (0, custom_validator_1.CustomValidate)(dateValidators[isDate.format], { each: !!base.isArray }) : core_1.noop, customValidate ? (0, custom_validator_1.CustomValidate)(customValidate, { each: !!base.isArray }) : core_1.noop);
exports.IsString = IsString;
//# sourceMappingURL=is-string.js.map