"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedHeaders = void 0;
const common_1 = require("@nestjs/common");
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const TypedHeaders = 
// eslint-disable-next-line @typescript-eslint/ban-types
() => (target, propertyKey, parameterIndex) => {
    const types = Reflect.getOwnMetadata('design:paramtypes', target, propertyKey);
    if (types === undefined) {
        throw new Error('Type metadata not found. See https://www.typescriptlang.org/docs/handbook/decorators.html#metadata');
    }
    const paramType = types[parameterIndex];
    (0, common_1.Headers)()(target, propertyKey, parameterIndex);
    HeaderSchema(paramType)(target, propertyKey, parameterIndex);
};
exports.TypedHeaders = TypedHeaders;
const HeaderSchema = (0, common_1.createParamDecorator)(async (value, ctx) => {
    // Extract headers
    const headers = ctx.switchToHttp().getRequest().headers;
    // Convert headers to DTO object
    const dto = (0, class_transformer_1.plainToClass)(value, headers, { excludeExtraneousValues: true });
    // Validate
    return (0, class_validator_1.validateOrReject)(dto).then(() => dto, (err) => {
        throw new common_1.BadRequestException(err.map((e) => Object.values(e.constraints)).flat());
    });
});
//# sourceMappingURL=typed-headers.decorator.js.map